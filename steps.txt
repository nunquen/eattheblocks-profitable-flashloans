- Download project 
     git clone https://github.com/jklepatch/eattheblocks.git

cp -r eattheblocks/profitable-flashloans/9-setup-project/ eattheblocks-profitable-flashloans

Open eattheblocks-profitable-flashloans folder in VSCode

npm install -g truffle
npm i dotenv
npm install web3
npm install @uniswap/sdk
    -> This installs the node_modules folder

create account in https://infura.io/
    user: saul.maldonado@gmail.com
    pass: Infur@.123.!

    create Etherium project -> Flashloan

    copy wws endpoint link --> wss://mainnet.infura.io/ws/v3/71241e04d2904598bcd18c505c182280

create .env file in root folder

create run-arbitrage.js in root folder of this project    
    - Open a websocket connection and subscribe to ETH header channel

    - Connect to Poll Kyber to get market data for Dai and Eth

        - In the same transaction we'll query Kyber for ETH-DAI and DAI-ETH

        - Normalize prices from Kyber

Fixes on @uniswap/sdk
    - Token.fetchData -> replece by Fetcher.fetchTokenData
    - Pair.fetchData -> replaced by Fetcher.fetchPairData


WARNING -- WARNING -- WARNING -- WARNING -- WARNING -- WARNING -- WARNING
    ========= NOTICE =========
    Request-Rate Exceeded  (this message will not be repeated)

    The default API keys for each service are provided as a highly-throttled,
    community resource for low-traffic projects and early prototyping.

    While your application will continue to function, we highly recommended
    signing up for your own API keys to improve performance, increase your
    request rate/limit and enable other perks, such as metrics and advanced APIs.

    For more details: https://docs.ethers.io/api-keys/
    ==========================
WARNING -- WARNING -- WARNING -- WARNING -- WARNING -- WARNING -- WARNING

npm install -g truffle

execute in your project's main folder

    truffel init .
    -> this will create the contract, migration and test folders and truffel-config.js

Getting ETH private key and address for testing
    - Go to https://vanity-eth.tk/ scroll bottom and get ETH address and private key
    - address and private key are saved in .env file 
    - in run-arbitrage.js 
        if (process.env.NODE_ENV.trim() == 'development'){
            PRIVATE_KEY = process.env.ETH_PRIVATE_KEY_FOR_TESTING;
        }
        // Setting private key in order to sign transactions in web3
        web3.eth.accounts.wallet.add(PRIVATE_KEY);

npm install @studydefi/money-legos

Create mmanually contracts/Flashloan.sol
    Go to https://money-legos.studydefi.com/#/dydx, copy the js and paste it into the new Flashloan.sol file
    Call inner class Flashloan
    Coding
        enum Direction { KyberToUniswap, UniswapToKyber }
        struct ArbInfo {
            Direction direction;
            uint256 repayAmount;
        }
        function initiateFlashLoan -> add 'Direction _direction' as input parameter
        -> Fit code as required for this changes

Include required interfaces: KyberNetworkProxy, IUniswapV2Router02, IWeth and IERC20
    - This interfaces will act as pointers for smart contracts
    - We'll need this constant value to deal with ETH in Kyber
        address constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    - This constructor is a special function that will be called when the smart contract is deployed to the blockchain
        constructor(
            address kyberAddress,
            address uniswapAddress,
            address weithAddress,
            address daiAddress
        ) public {
            // Instantiating all pointers   
            kyber = IKyberNetworkProxy(kyberAddress);
            uniswap = IUniswapV2Router02(uniswapAddress);
            weth = IWeth(weithAddress);
            dai = IERC20(daiAddress);
        }
    - This is the function that will be called postLoan
        // i.e. Encode the logic to handle your flashloaned funds here
        function callFunction(
            address sender,
            Account.Info memory account,
            bytes memory data
        ) public {
            ArbInfo memory arbInfo = abi.decode(data, (ArbInfo));
            // getting dai balance of the current contract
            unit256 balanceDai = dai.balanceOf(address(this));

            // IMPORTANT: this required section is where the contract is valid.
            //            if something fails then the contract will fial.
            require(
                balanceDai >= arbInfo.repayAmount,
                "Not enough funds to repay DyDx loan!"
            );
        }

    - In the body of this function we'll include the direction of our trades.
      The first direction is "Buy in Kyber and sell in Uniswap"
        if (arbInfo.direction == Direction.KyberToUniswap) {
            // Buy ETH on Kyber
            dai.approve(address(kyber), balanceDai);
            // Asigning the expected rate to a tuple and ignoring the second value for this tuple
            (uint expectedRate, ) = kyber.getExpectedRate(
                //Pointer to the token
                dai,
                //Pointer to the output token
                IERC20(KYBER_ETH_ADDRESS),
                //Amount of dai we want to trade
                balanceDai
            );
            // Trading on kyber
            kyber.swapTokenToEther(dai, balanceDai, expectedRate);

            // Sell it on Uniswap: we must define the path for trading.
            //    In Unisawp we can trade from asset A, to B and then finally to C
            //    Aldough we'll be only trading with "A" we still must define a path 
            // Declaring an array of 2 in Solidity
            address memory path = new address[](2);
            // Remember: in Uniswap we don't work with Ether bu with weth
            path[0] = address(weth);
            path[1] = address(dai);

            uint[] memory minOuts = uniswap.getAmountsOut(address(this).balance, path);

            // Trading on Uniswap
            uniswap.swapETHForExactTokens.value(address(this).balance)(
                minOuts[2],
                path,
                address(this),
                // Deadline 
                now );
        }

    - Important: at the end of this script we must define a fullback function 
        // Fullback function (mandatory)
        function() external payable{}

    - The second direction is "Buy in Uniswap and sell in Kyber"
    if (arbInfo.direction == Direction.UniswapToKyber) {
            // Buy ETH on Uniswap
            dai.approve(address(uniswap), balanceDai);

            address memory path = new address[](2);
            // Remember: in Uniswap we don't work with Ether bu with weth
            path[0] = address(dai);
            path[1] = address(weth);

            uint[] memory minOuts = uniswap.getAmountsOut(balanceDai, path);

            // Trading on Uniswap
            uniswap.swapExactTokensForETH(
                balancedai, 
                minOuts[1],
                path,
                address(this),
                // Deadline 
                now );

            // Sell ETH on Kyber
            (uint expectedRate, ) = uniswap.getExpectedRate(
                //Pointer to the output token
                IERC20(KYBER_ETH_ADDRESS),
                //Pointer to the token
                dai,
                //Amount of Ether we want to trade
                address(this).balance
            );
            // Trading on kyber
            kyber.swapEtherToToken.value(address(this).balance)(
                dai, 
                expectedRate
                );
        }

    - Important: must check if the contract is valid

        // IMPORTANT: this required section is where the contract is valid.
        //            if something fails then the contract will fial.
        require(
            dai.balanceOf(address(this)) >= arbInfo.repayAmount,
            "Not enough funds to repay DyDx loan!"
        );

    - Calculating profit and withdraw 
        // Withdraw profit
        // 1.- Calculating profit
        uint profit = dai.balanceOf(address(this)) - arbInfo.repayAmount;
        // 2.- Send profit to the beficiary address
        dai.transfer(beneficiary, profit);
        // 3.- Emit an event to describe the arbitrage that already happend
        emit NewArbitrage(arbInfo.direction, profit, now);

    - Definde in the top section of this Flashloan contract
         event NewArbitrage( 
            Direction direction,
            uint profit,
            uint date
        );

        